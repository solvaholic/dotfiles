#!/bin/sh
#
# Run `script/setup` to set up `dotfiles` in, or reset
# `dotfiles` to, its initial state.
#
# This covers shell and desktop preferences.
#
# This will _not_ run the OS-specific `setup` script.
#
# - Call `../git/setup` to set my Git configuration.
# - ???
# - Symlink config files and directories in the right places.
#

# TODO: Add debugging.

script_name=script/setup
# TODO: Set script_name programmatically.

# Initialize the warnings counter.
with_warnings=0

#
# Make sure `setup` was called in a way we can get its path.
#
if [ -f "$0" ] && [ $( dirname "$0" ) ]; then
  # $0 is a file and `dirname` succeeds, so we think Yes.
  script_root="$( cd $( dirname "$0" ) && echo $PWD )"
else
  # $0 is not a file or `dirname` fails, so we think No.
  script_root=
  printf "\n[FAIL] $script_name: This script was called incorrectly. Unable to set \$script_root.\n\n"
  exit 1
fi

#
# Call dotfiles.sh to set some variables and define some functions.
#
if [ -x "$script_root/../dotfiles.sh" ]; then
  . "$script_root/../dotfiles.sh"
else
  printf "\n[FAIL] $script_name: Can't find 'dotfiles.sh'. Abort!\n\n"
  exit 1
fi


# TODO: Answer: Can we expect readlink to be available?


#
# Define link_file() function for creating symlinks.
#
link_file () {
  # Take $source and $target as parameters. Create a link ($target) to
  # $source. If $target already exists but is _not_ a link to $source
  # then ask the user what to do.

  local source="$1" target="$2"
  local overwrite= backup= skip= action=

  # Do $source and $target look like valid paths? If not then return 1.
  if [ ! -e "$source" ]; then
    fail "$script_name: \$source '$source' doesn't exist!"
    return 1
  elif [ ! -d "$( dirname "$target" )" ]; then
    fail "$script_name: \$target '$target' path is invalid!"
    return 1
  fi

  # If the target already exists, then prompt the user for action.
  if [ -e "$target" ]; then

    # link_file() inherits overwrite_all, backup_all, and skip_all
    # from the caller.

    if [ "$overwrite_all" = "false" ] && [ "$backup_all" = "false" ] && [ "$skip_all" = "false" ]
    then

      if [ -h "$target" ]; then
        # Target is a link. What's it point to?
        local currentSrc="$(readlink $target)"
      else
        local currentSrc=
      fi

      # If $target is already a link to $source then then assume "[s]kip".
      if [ ! -z "$currentSrc" ] && [ "$currentSrc" = "$source" ]; then
        skip="true";
      else

        user "File already exists: $target ($(basename "$source"))"
        user "What do you want to do?"

        # TODO: Validate input here.

        user "[s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all?"
        read action

        case "$action" in
          o )
            overwrite="true";;
          O )
            overwrite_all="true";;
          b )
            backup="true";;
          B )
            backup_all="true";;
          s )
            skip="true";;
          S )
            skip_all="true";;
          * )
            ;;
        esac

      fi

    fi

    overwrite=${overwrite:-$overwrite_all}
    backup=${backup:-$backup_all}
    skip=${skip:-$skip_all}

    if [ "$overwrite" = "true" ]; then
      rm -rf "$target"
      success "$script_name: Removed '$target'."
    elif [ "$backup" = "true" ]; then
      mv "$target" "${target}.backup"
      success "$script_name: Moved '$target' to '${target}.backup'."
    elif [ "$skip" = "true" ]; then
      success "$script_name: '$target' is already installed."
    fi
  fi

  if [ "$skip" != "true" ]; then
    ln -s "$source" "$target"
    success "$script_name: Linked '$source' to '$target'."
  fi
}

install_dotfiles () {
  info "$script_name: Installing dotfiles..."

  local overwrite_all="false" backup_all="false" skip_all="false"

  # TODO: Fix this so it'll handle filenames that have spaces.
  for source in $(find -H "$DOTFILES_ROOT" -maxdepth 2 -name '*.symlink' ! -path '*.git*')
  do
    target="$HOME/.$(basename "${source%.*}")"
    link_file "$source" "$target"
  done

  # find -H "$DOTFILES_ROOT" -maxdepth 2 -name '*.symlink' ! -path '*/.git/*' | while read line; do
  #   target="$HOME/.$(basename "${line%.*}")"
  #   link_file "$source" "$target"
  # done

}

# Run our git/setup to create git/gitconfig.local.symlink
if [ -x "$DOTFILES_ROOT/git/setup" ]; then
  info "$script_name: Running git/setup now..."
  "$DOTFILES_ROOT/git/setup"
else
  user "$script_name: Can't find git/setup, or it's not executable."
fi

# What else do we need to do, before we install the dotfiles?

# Install dotfiles.
install_dotfiles

# Prompt to run $whichos/bootstrap, if it exists.
if [ -e "$DOTFILES_ROOT/$whichos/bootstrap" ]; then
  user "$script_name: Finished! You may wish to run '$whichos/setup' next."
else
  success "$script_name: Finished!"
fi
