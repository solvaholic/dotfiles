#   bootstrap:
#     - Set $DOTFILES_SHELL, prefer /bin/bash or /bin/sh.
#     - Run under $DOTFILES_SHELL, unless it's set to "current".
#     - Figure out $DOTFILES_ROOT.
#     - Figure out $DOTFILES_OS.
#     - Write ~/.dotfiles.conf.
#     - Load ~/.dotfiles.conf and $DOTFILES_ROOT/dotfiles.sh.
#     - Make sure we have git.


# Make sure we can tell where we are.
# $0 should be this script, and it should be executable.
if [ ! -x "$0" ] || [ ! -x "${0%/*}" ]; then
  echo -e "\n\nHow did you get here?\n\n\$0 is '$0'.\n\n"
  exit 1
fi


# Set $DOTFILES_SHELL, prefer /bin/bash or /bin/sh.
if [ -n "$DOTFILES_SHELL" ]; then
  # $DOTFILES_SHELL has non-zero length, skip discovery.
  DOTFILES_SHELL="$DOTFILES_SHELL"
elif [ -x /bin/bash ]; then
  # $DOTFILES_SHELL has zero length, use /bin/bash.
  DOTFILES_SHELL=/bin/bash
elif [ -x /bin/sh ]; then
  # $DOTFILES_SHELL has zero length, use /bin/sh.
  DOTFILES_SHELL=/bin/sh
else
  echo -e "\n\nDid not find /bin/sh or /bin/bash."\
          "Continuing with your current shell.\n\n"
  DOTFILES_SHELL=current
fi


# Run under $DOTFILES_SHELL, unless it's set to "current".
if [ -z "$DOTFILES_EXEC" ] && [ "$DOTFILES_SHELL" != "current" ]; then
  # $DOTFILES_EXEC is not set and $DOTFILES_SHELL is not "current".
  # Set $DOTFILES_EXEC here, so we won't loop.
  exec "$DOTFILES_SHELL" -c "DOTFILES_EXEC=$DOTFILES_SHELL $0"
fi


# Figure out $DOTFILES_ROOT.
# cd into $0's directory then ask Git to find the root of the repo.
# TODO: More robust or elegant way to do this?
cd "${0%/*}" && DOTFILES_ROOT="$(git rev-parse --show-toplevel)" || \
echo -e "\n\nShit broke, yo."


# Figure out $DOTFILES_OS.
# Will be one of: MacOS, Linux, OpenBSD, or idfkbro
case "$(uname)" in
  *Linux)
    DOTFILES_OS='Linux'
    ;;
  Darwin)
    DOTFILES_OS='MacOS'
    ;;
  OpenBSD)
    DOTFILES_OS="OpenBSD"
    ;;
  *)
    DOTFILES_OS="idkbro"
    ;;
esac


# Write ~/.dotfiles.conf.
if touch ~/.dotfiles.conf; then
  echo -e "# Generated by dotfiles/script/bootstrap." > ~/.dotfiles.conf
  echo -e "export DOTFILES_ROOT=\"$DOTFILES_ROOT\"" >> ~/.dotfiles.conf
  echo -e "export DOTFILES_SHELL=\"$DOTFILES_SHELL\"" >> ~/.dotfiles.conf
  echo -e "export DOTFILES_OS=\"$DOTFILES_OS\"" >> ~/.dotfiles.conf
else
  echo -e "\n\nUnable to write ~/.dotfiles.conf.\n\n"
  exit 1
fi


# Load ~/.dotfiles.conf and $DOTFILES_ROOT/dotfiles.sh.
if . ~/.dotfiles.conf && [ -x "$DOTFILES_ROOT" ]; then
  # Found and loaded ~/.dotfiles.conf OK.
  if . "$DOTFILES_ROOT/dotfiles.sh"; then
    # Found and ran dotfiles.sh OK.
    debug "$0: Loaded ~/.dotfiles.conf and $DOTFILES_ROOT/dotfiles.sh OK."
  else
    echo -e "\n\nMissing $DOTFILES_ROOT/dotfiles.sh"
    echo -e "Please check your dotfiles installation.\n\n"
    exit 1
  fi
else
  # We really, really should not be able to reach here.
  echo -e "\n\nMissing ~/.dotfiles.conf"
  echo -e "Please run dotfiles/script/bootstrap .. again?\n\n"
  exit 1
fi


# Make sure we have the commands we'll need.
# TODO: What other prerequisites should we check for?

if _cmd=$(which docker || which docker.exe); then
  debug "$0: Found '${_cmd##*/}' OK."
else
  fail "Did not find 'docker' or 'docker.exe'. Fix that, and try again."
  exit 1
fi

for _cmd in git unzip curl mktemp; do

  if [ -x "$(which "${_cmd}")" ]; then
    debug "$0: Found '${_cmd}' OK."
  else
    fail "Did not find '${_cmd}'. Fix that, and try again."
    exit 1
  fi

done

# If we made it this far then we think everything went OK.
success "$0: Success."
exit 0
